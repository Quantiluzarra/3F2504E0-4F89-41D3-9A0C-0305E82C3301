<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Multicolor Square</title>
<style>
  :root{
    --bg:#070a10;
    --panel: rgba(16,20,30,.62);
    --panel2: rgba(10,14,22,.72);
    --line: rgba(255,255,255,.10);
    --text: rgba(245,250,255,.92);
    --muted: rgba(190,205,223,.70);
    --a1:#6E7BFF;
    --a2:#20D2A2;
    --a3:#FF5CAD;
    --shadow: 0 28px 90px rgba(0,0,0,.6);
    --r: 18px;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    --ease: cubic-bezier(.2,.85,.2,1);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: var(--sans);
    color: var(--text);
    background: var(--bg);
    overflow:hidden;
  }

  /* Infinite animated background (fat but clean) */
  body::before{
    content:"";
    position: fixed;
    inset:-20%;
    z-index:-2;
    background:
      radial-gradient(820px 620px at 12% 15%, rgba(110,123,255,.34), transparent 62%),
      radial-gradient(820px 620px at 88% 20%, rgba(32,210,162,.22), transparent 64%),
      radial-gradient(820px 620px at 50% 92%, rgba(255,92,173,.18), transparent 62%),
      linear-gradient(-45deg, rgba(110,123,255,.15), rgba(32,210,162,.10), rgba(255,92,173,.10), rgba(110,123,255,.15));
    background-size: 160% 160%;
    filter: saturate(1.2) contrast(1.06);
    animation: bgMove 12s var(--ease) infinite alternate;
    transform: translateZ(0);
  }
  @keyframes bgMove{
    0%{ background-position: 0% 50%; transform: scale(1.02) rotate(-.15deg); }
    100%{ background-position: 100% 50%; transform: scale(1.06) rotate(.15deg); }
  }

  body::after{
    content:"";
    position: fixed;
    inset:0;
    z-index:-1;
    opacity:.26;
    background-image:
      repeating-linear-gradient( 90deg, rgba(255,255,255,.06) 0 1px, transparent 1px 44px),
      repeating-linear-gradient(180deg, rgba(255,255,255,.05) 0 1px, transparent 1px 44px),
      repeating-linear-gradient(-45deg, rgba(110,123,255,0) 0 18px, rgba(110,123,255,.12) 18px 19px, rgba(110,123,255,0) 19px 38px);
    background-size: 44px 44px, 44px 44px, 160px 160px;
    animation: gridFlow 26s linear infinite;
    mask-image: radial-gradient(circle at 50% 40%, black 0 58%, transparent 80%);
    pointer-events:none;
  }
  @keyframes gridFlow{
    from{ background-position: 0 0, 0 0, 0 0; }
    to{ background-position: -1200px 0, 0 -900px, 700px 300px; }
  }

  @media (prefers-reduced-motion: reduce){
    body::before, body::after{ animation:none !important; }
  }

  /* Layout */
  .app{
    height:100%;
    display:grid;
    grid-template-columns: 340px 1fr;
    gap: 14px;
    padding: 14px;
  }
  @media (max-width: 980px){
    body{ overflow:auto; }
    .app{ grid-template-columns: 1fr; }
  }

  .panel{
    border: 1px solid var(--line);
    border-radius: var(--r);
    background: linear-gradient(180deg, var(--panel), var(--panel2));
    box-shadow: var(--shadow);
    backdrop-filter: blur(14px);
    overflow:hidden;
  }

  .pHead{
    padding: 14px 14px 10px;
    border-bottom: 1px solid rgba(255,255,255,.09);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .brand{
    display:flex; align-items:center; gap:12px;
  }
  .logo{
    width: 36px; height: 36px;
    border-radius: 14px;
    background: conic-gradient(from 180deg, var(--a1), var(--a2), var(--a3), var(--a1));
    box-shadow: 0 0 0 3px rgba(255,255,255,.06), 0 20px 60px rgba(110,123,255,.18);
    position:relative;
    overflow:hidden;
  }
  .logo::after{
    content:"";
    position:absolute; inset:-70%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.22), transparent 55%);
    animation: sheen 3.0s var(--ease) infinite;
  }
  @keyframes sheen{
    0%{ transform: translate3d(-12%, -10%, 0) rotate(8deg); opacity:.18; }
    50%{ transform: translate3d(12%, 10%, 0) rotate(18deg); opacity:.28; }
    100%{ transform: translate3d(-12%, -10%, 0) rotate(8deg); opacity:.18; }
  }
  @media (prefers-reduced-motion: reduce){ .logo::after{ animation:none !important; } }

  .name{
    margin:0;
    font-size: 14px;
    letter-spacing: 2.6px;
    text-transform: uppercase;
  }
  .mini{
    margin-top: 4px;
    font-family: var(--mono);
    font-size: 12px;
    color: var(--muted);
  }

  .pBody{ padding: 12px 14px 14px; display:grid; gap:10px; }
  .row{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
  .row1{ display:grid; grid-template-columns: 1fr; gap:10px; }

  .field{
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.04);
    border-radius: 14px;
    padding: 10px;
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .lab{
    font-family: var(--mono);
    font-size: 12px;
    color: rgba(190,205,223,.70);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
  }
  input[type="range"]{ width:100%; }
  input[type="color"]{
    width: 100%;
    height: 34px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,.14);
    background: transparent;
    padding: 0;
  }
  select, button{
    font-family: inherit;
  }

  .btnRow{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
  }
  .btn{
    border: 1px solid rgba(110,123,255,.45);
    background: rgba(110,123,255,.14);
    color: var(--text);
    padding: 10px 12px;
    border-radius: 14px;
    cursor:pointer;
    font-size: 13px;
    user-select:none;
    position:relative;
    overflow:hidden;
    transition: transform 200ms var(--ease), background 200ms var(--ease), border-color 200ms var(--ease);
  }
  .btn:hover{ transform: translateY(-1px); background: rgba(110,123,255,.20); border-color: rgba(32,210,162,.40); }
  .btn:active{ transform: translateY(0) scale(.99); }
  .btn.ghost{
    border-color: rgba(255,255,255,.14);
    background: rgba(255,255,255,.04);
    color: var(--muted);
  }
  .btn.ghost:hover{ background: rgba(255,255,255,.06); color: var(--text); border-color: rgba(255,255,255,.20); }
  .toggle{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
  }
  .sw{
    width: 44px; height: 26px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,.16);
    background: rgba(255,255,255,.06);
    position:relative;
    cursor:pointer;
    flex: 0 0 auto;
    transition: background 200ms var(--ease);
  }
  .sw i{
    position:absolute; top: 3px; left: 3px;
    width: 20px; height: 20px;
    border-radius: 999px;
    background: rgba(245,250,255,.85);
    box-shadow: 0 12px 24px rgba(0,0,0,.25);
    transition: transform 220ms var(--ease), background 220ms var(--ease);
  }
  .sw.on{ background: rgba(32,210,162,.14); border-color: rgba(32,210,162,.35); }
  .sw.on i{ transform: translateX(18px); background: rgba(32,210,162,.92); }

  .hint{
    font-family: var(--mono);
    font-size: 12px;
    color: rgba(190,205,223,.60);
    padding-top: 4px;
  }

  /* Canvas area */
  .stage{
    border: 1px solid var(--line);
    border-radius: var(--r);
    background: rgba(0,0,0,.16);
    box-shadow: var(--shadow);
    position: relative;
    overflow:hidden;
    min-height: 520px;
  }
  .stageInner{
    position:absolute;
    inset:0;
    display:grid;
    place-items:center;
  }
  .canWrap{
    position: relative;
    transform: translateZ(0);
    will-change: transform;
  }
  canvas{
    display:block;
    border-radius: 14px;
    background: #0b0f17;
    box-shadow: 0 26px 80px rgba(0,0,0,.55);
    touch-action: none; /* important for pointer drawing */
  }
  #gridOverlay{
    position:absolute;
    inset:0;
    pointer-events:none;
    background: transparent;
  }

  .toast{
    position: fixed;
    right: 14px;
    bottom: 14px;
    z-index: 50;
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 16px;
    background: rgba(10,14,22,.78);
    backdrop-filter: blur(12px);
    padding: 10px 12px;
    display:none;
    box-shadow: 0 20px 60px rgba(0,0,0,.45);
    min-width: min(360px, calc(100vw - 28px));
  }
  .toast.show{ display:block; animation: toastIn 220ms var(--ease) both; }
  @keyframes toastIn{
    from{ transform: translateY(10px); opacity: 0; }
    to{ transform: translateY(0); opacity: 1; }
  }
  .toast .t1{ font-size: 13px; }
  .toast .t2{ margin-top: 6px; font-family: var(--mono); font-size: 12px; color: rgba(190,205,223,.70); }

</style>
</head>

<body>
  <div class="app">
    <!-- Left: settings -->
    <aside class="panel" aria-label="Settings">
      <div class="pHead">
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div>
            <h1 class="name">MULTICOLOR SQUARE</h1>
            <div class="mini">pixel canvas</div>
          </div>
        </div>
        <button class="btn ghost" id="newBtn" type="button" title="New">New</button>
      </div>

      <div class="pBody">
        <div class="row">
          <div class="field">
            <div class="lab"><span>Grid</span><span id="gridVal">48</span></div>
            <input id="grid" type="range" min="16" max="160" value="48" step="1" />
          </div>
          <div class="field">
            <div class="lab"><span>Brush</span><span id="brushVal">1</span></div>
            <input id="brush" type="range" min="1" max="8" value="1" step="1" />
          </div>
        </div>

        <div class="row">
          <div class="field">
            <div class="lab"><span>Color</span><span id="hexOut">#20D2A2</span></div>
            <input id="color" type="color" value="#20D2A2"/>
          </div>
          <div class="field">
            <div class="lab"><span>Zoom</span><span id="zoomVal">100%</span></div>
            <input id="zoom" type="range" min="60" max="180" value="100" step="1" />
          </div>
        </div>

        <div class="field">
          <div class="toggle">
            <div class="lab" style="margin:0;"><span>Rainbow</span><span id="rbHint"></span></div>
            <div class="sw" id="rb"><i></i></div>
          </div>
          <div class="toggle" style="margin-top:10px;">
            <div class="lab" style="margin:0;"><span>Eraser</span><span></span></div>
            <div class="sw" id="er"><i></i></div>
          </div>
          <div class="toggle" style="margin-top:10px;">
            <div class="lab" style="margin:0;"><span>Grid lines</span><span></span></div>
            <div class="sw on" id="gl"><i></i></div>
          </div>
        </div>

        <div class="btnRow">
          <button class="btn ghost" id="undoBtn" type="button">Undo</button>
          <button class="btn ghost" id="redoBtn" type="button">Redo</button>
          <button class="btn ghost" id="clearBtn" type="button">Clear</button>
          <button class="btn" id="saveBtn" type="button">Save PNG</button>
        </div>

        <div class="btnRow">
          <button class="btn ghost" id="exportBtn" type="button">Export</button>
          <button class="btn ghost" id="importBtn" type="button">Import</button>
          <input id="fileIn" type="file" accept="application/json" style="display:none;">
        </div>

        <div class="hint">
          Draw: hold LMB + move • Touch: draw with finger
        </div>
      </div>
    </aside>

    <!-- Right: canvas -->
    <section class="stage panel" aria-label="Canvas">
      <div class="stageInner">
        <div class="canWrap" id="canWrap">
          <canvas id="paint"></canvas>
          <canvas id="gridOverlay"></canvas>
        </div>
      </div>
    </section>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite">
    <div class="t1" id="t1">OK</div>
    <div class="t2" id="t2">…</div>
  </div>

<script>
(() => {
  const $ = (s, r=document) => r.querySelector(s);
  const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

  const canvas = $('#paint');
  const ctx = canvas.getContext('2d', { alpha: false });
  const gridCanvas = $('#gridOverlay');
  const gctx = gridCanvas.getContext('2d');

  const gridSlider = $('#grid');
  const brushSlider = $('#brush');
  const zoomSlider = $('#zoom');
  const colorPicker = $('#color');

  const gridVal = $('#gridVal');
  const brushVal = $('#brushVal');
  const zoomVal = $('#zoomVal');
  const hexOut = $('#hexOut');

  const rbSw = $('#rb');
  const erSw = $('#er');
  const glSw = $('#gl');

  const newBtn = $('#newBtn');
  const undoBtn = $('#undoBtn');
  const redoBtn = $('#redoBtn');
  const clearBtn = $('#clearBtn');
  const saveBtn = $('#saveBtn');
  const exportBtn = $('#exportBtn');
  const importBtn = $('#importBtn');
  const fileIn = $('#fileIn');

  const canWrap = $('#canWrap');

  const toastEl = $('#toast');
  const t1 = $('#t1');
  const t2 = $('#t2');
  let toastTimer = 0;
  function toast(a, b=''){
    t1.textContent = a; t2.textContent = b;
    toastEl.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>toastEl.classList.remove('show'), 2200);
  }

  // state
  let N = +gridSlider.value;           // grid count (NxN)
  let brush = +brushSlider.value;      // brush size in cells
  let zoom = +zoomSlider.value / 100;  // visual zoom
  let showGrid = true;
  let rainbow = false;
  let eraser = false;

  const BG = 0x0b0f17; // background color in RGB (same as canvas CSS)
  let pixels = new Uint32Array(N*N); // store as 0xRRGGBB
  pixels.fill(BG);

  // undo/redo: each action = { idxs:[], prev:[], next:[] }
  const undo = [];
  const redo = [];
  const MAX_STACK = 60;

  // pointer draw
  let drawing = false;
  let lastCell = -1;
  let currentAction = null;

  function hexToRgbInt(hex){
    const s = hex.replace('#','').trim();
    const v = parseInt(s, 16);
    return v & 0xFFFFFF;
  }
  function rgbIntToHex(v){
    return '#' + (v >>> 0).toString(16).padStart(6,'0').toUpperCase();
  }
  function hslToRgbInt(h, s, l){
    // h [0..360), s,l [0..1]
    h = ((h % 360) + 360) % 360;
    const c = (1 - Math.abs(2*l - 1)) * s;
    const x = c * (1 - Math.abs(((h/60) % 2) - 1));
    const m = l - c/2;
    let r=0,g=0,b=0;
    if(h < 60){ r=c; g=x; b=0; }
    else if(h < 120){ r=x; g=c; b=0; }
    else if(h < 180){ r=0; g=c; b=x; }
    else if(h < 240){ r=0; g=x; b=c; }
    else if(h < 300){ r=x; g=0; b=c; }
    else { r=c; g=0; b=x; }
    const R = Math.round((r+m)*255);
    const G = Math.round((g+m)*255);
    const B = Math.round((b+m)*255);
    return (R<<16) | (G<<8) | B;
  }

  function setSwitch(sw, on){
    sw.classList.toggle('on', !!on);
  }

  function updateUI(){
    gridVal.textContent = String(N);
    brushVal.textContent = String(brush);
    zoomVal.textContent = Math.round(zoom*100) + '%';
    hexOut.textContent = colorPicker.value.toUpperCase();
    setSwitch(rbSw, rainbow);
    setSwitch(erSw, eraser);
    setSwitch(glSw, showGrid);
  }

  function calcCanvasSize(){
    const stage = document.querySelector('.stage');
    const r = stage.getBoundingClientRect();
    // keep square, leave padding
    const pad = 26;
    const size = Math.max(280, Math.min(r.width - pad, r.height - pad));
    return Math.floor(size);
  }

  function setupCanvases(){
    const size = calcCanvasSize();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

    // internal resolution = size*dpr, but we draw cells onto it exactly
    canvas.width = Math.floor(size * dpr);
    canvas.height = Math.floor(size * dpr);
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';

    gridCanvas.width = canvas.width;
    gridCanvas.height = canvas.height;
    gridCanvas.style.width = canvas.style.width;
    gridCanvas.style.height = canvas.style.height;

    ctx.setTransform(dpr,0,0,dpr,0,0);
    gctx.setTransform(dpr,0,0,dpr,0,0);

    canWrap.style.transform = `scale(${zoom})`;
    drawAll();
    drawGrid();
  }

  function cellSizePx(){
    // in CSS pixels
    const size = parseFloat(canvas.style.width) || 600;
    return size / N;
  }

  function drawAll(){
    const size = parseFloat(canvas.style.width) || 600;
    const cs = size / N;

    // Fill background fast
    ctx.fillStyle = '#' + BG.toString(16).padStart(6,'0');
    ctx.fillRect(0,0,size,size);

    // Draw cells
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const idx = y*N + x;
        const col = pixels[idx];
        if(col === BG) continue;
        ctx.fillStyle = '#' + (col>>>0).toString(16).padStart(6,'0');
        ctx.fillRect(x*cs, y*cs, cs, cs);
      }
    }
  }

  function drawGrid(){
    const size = parseFloat(gridCanvas.style.width) || 600;
    const cs = size / N;

    gctx.clearRect(0,0,size,size);
    if(!showGrid) return;

    gctx.globalAlpha = 0.55;
    gctx.lineWidth = 1;
    gctx.strokeStyle = 'rgba(255,255,255,.10)';

    // avoid heavy grid for huge N: draw every 2 or 4 lines
    let step = 1;
    if(N >= 96) step = 2;
    if(N >= 128) step = 4;

    gctx.beginPath();
    for(let i=0;i<=N;i+=step){
      const p = i*cs;
      gctx.moveTo(p, 0); gctx.lineTo(p, size);
      gctx.moveTo(0, p); gctx.lineTo(size, p);
    }
    gctx.stroke();
    gctx.globalAlpha = 1;
  }

  function paintCell(x, y, col){
    if(x < 0 || y < 0 || x >= N || y >= N) return;
    const idx = y*N + x;

    // record action patch
    const prev = pixels[idx];
    if(prev === col) return;

    // for current stroke: store each idx once
    if(currentAction){
      if(!currentAction.seen.has(idx)){
        currentAction.seen.add(idx);
        currentAction.idxs.push(idx);
        currentAction.prev.push(prev);
        currentAction.next.push(col);
      }
    }

    pixels[idx] = col;

    // draw only this cell
    const size = parseFloat(canvas.style.width) || 600;
    const cs = size / N;
    ctx.fillStyle = '#' + (col>>>0).toString(16).padStart(6,'0');
    ctx.fillRect(x*cs, y*cs, cs, cs);
  }

  function paintBrush(cx, cy){
    const half = Math.floor(brush / 2);
    const base = eraser ? BG : hexToRgbInt(colorPicker.value);
    const t = performance.now() * 0.001;

    for(let dy=-half; dy< -half+brush; dy++){
      for(let dx=-half; dx< -half+brush; dx++){
        const x = cx + dx;
        const y = cy + dy;

        let col = base;
        if(rainbow && !eraser){
          const hue = (t*90 + (x*9) + (y*7)) % 360;
          col = hslToRgbInt(hue, 1.0, 0.55);
        }
        paintCell(x, y, col);
      }
    }
  }

  function posToCell(e){
    const rect = canvas.getBoundingClientRect();
    const size = rect.width; // CSS px
    const cs = size / N;
    const x = Math.floor((e.clientX - rect.left) / cs);
    const y = Math.floor((e.clientY - rect.top) / cs);
    return { x, y };
  }

  function beginStroke(){
    currentAction = { idxs:[], prev:[], next:[], seen: new Set() };
  }
  function endStroke(){
    if(!currentAction) return;
    if(currentAction.idxs.length){
      // push to undo stack
      undo.push({
        idxs: currentAction.idxs,
        prev: currentAction.prev,
        next: currentAction.next
      });
      if(undo.length > MAX_STACK) undo.shift();
      redo.length = 0;
    }
    currentAction = null;
  }

  function doUndo(){
    const a = undo.pop();
    if(!a) return;
    for(let i=0;i<a.idxs.length;i++){
      pixels[a.idxs[i]] = a.prev[i];
    }
    redo.push(a);
    drawAll();
    toast('Undo', `${a.idxs.length} cells`);
  }
  function doRedo(){
    const a = redo.pop();
    if(!a) return;
    for(let i=0;i<a.idxs.length;i++){
      pixels[a.idxs[i]] = a.next[i];
    }
    undo.push(a);
    drawAll();
    toast('Redo', `${a.idxs.length} cells`);
  }

  function clearAll(){
    const prev = Array.from(pixels);
    pixels.fill(BG);
    drawAll();
    undo.push({
      idxs: prev.map((_,i)=>i),
      prev: prev,
      next: Array(prev.length).fill(BG)
    });
    if(undo.length > MAX_STACK) undo.shift();
    redo.length = 0;
    toast('Clear', 'Canvas reset');
  }

  function newCanvas(){
    // reset stacks and pixels
    undo.length = 0; redo.length = 0;
    pixels = new Uint32Array(N*N);
    pixels.fill(BG);
    drawAll();
    drawGrid();
    toast('New', `${N}×${N}`);
  }

  function savePNG(){
    // render to offscreen at higher resolution: each cell = 20px (nice)
    const cellPx = 20;
    const outSize = N * cellPx;
    const off = document.createElement('canvas');
    off.width = outSize;
    off.height = outSize;
    const o = off.getContext('2d', { alpha: false });

    // background
    o.fillStyle = '#' + BG.toString(16).padStart(6,'0');
    o.fillRect(0,0,outSize,outSize);

    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const idx = y*N + x;
        const col = pixels[idx];
        if(col === BG) continue;
        o.fillStyle = '#' + (col>>>0).toString(16).padStart(6,'0');
        o.fillRect(x*cellPx, y*cellPx, cellPx, cellPx);
      }
    }

    const url = off.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = `multicolor-square_${N}x${N}.png`;
    a.click();
    toast('Saved', a.download);
  }

  function exportJSON(){
    const payload = {
      app: 'Multicolor Square',
      v: 1,
      N,
      BG,
      pixels: Array.from(pixels) // simple + portable
    };
    const blob = new Blob([JSON.stringify(payload)], { type:'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `multicolor-square_${N}x${N}.json`;
    a.click();
    URL.revokeObjectURL(url);
    toast('Export', a.download);
  }

  async function importJSONFile(file){
    try{
      const text = await file.text();
      const data = JSON.parse(text);
      if(!data || data.app !== 'Multicolor Square' || !Number.isFinite(data.N) || !Array.isArray(data.pixels)){
        toast('Import', 'Invalid file');
        return;
      }
      N = clamp(data.N|0, 16, 160);
      gridSlider.value = String(N);
      pixels = new Uint32Array(N*N);
      const arr = data.pixels;
      for(let i=0;i<pixels.length;i++){
        pixels[i] = (arr[i] >>> 0) & 0xFFFFFF;
      }
      undo.length = 0; redo.length = 0;
      updateUI();
      setupCanvases();
      toast('Import', `${N}×${N}`);
    }catch(e){
      toast('Import', 'Error');
    }
  }

  // pointer events for draw
  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    drawing = true;
    lastCell = -1;
    beginStroke();
    const {x,y} = posToCell(e);
    const cell = y*N + x;
    lastCell = cell;
    paintBrush(x,y);
  });

  canvas.addEventListener('pointermove', (e) => {
    if(!drawing) return;
    const {x,y} = posToCell(e);
    const cell = y*N + x;
    if(cell === lastCell) return;
    lastCell = cell;
    paintBrush(x,y);
  });

  const end = () => {
    if(!drawing) return;
    drawing = false;
    lastCell = -1;
    endStroke();
  };
  canvas.addEventListener('pointerup', end);
  canvas.addEventListener('pointercancel', end);
  canvas.addEventListener('pointerleave', (e) => { /* keep drawing if captured */ });

  // Controls
  gridSlider.addEventListener('input', () => {
    N = +gridSlider.value;
    updateUI();
  });
  gridSlider.addEventListener('change', () => {
    // resizing grid wipes canvas (kept minimal)
    newCanvas();
    setupCanvases();
  });

  brushSlider.addEventListener('input', () => {
    brush = +brushSlider.value;
    updateUI();
  });

  zoomSlider.addEventListener('input', () => {
    zoom = +zoomSlider.value / 100;
    updateUI();
    canWrap.style.transform = `scale(${zoom})`;
  });

  colorPicker.addEventListener('input', () => {
    hexOut.textContent = colorPicker.value.toUpperCase();
    if(eraser){
      eraser = false;
      setSwitch(erSw, eraser);
    }
  });

  rbSw.addEventListener('click', () => {
    rainbow = !rainbow;
    setSwitch(rbSw, rainbow);
    toast('Rainbow', rainbow ? 'ON' : 'OFF');
  });

  erSw.addEventListener('click', () => {
    eraser = !eraser;
    setSwitch(erSw, eraser);
    toast('Eraser', eraser ? 'ON' : 'OFF');
  });

  glSw.addEventListener('click', () => {
    showGrid = !showGrid;
    setSwitch(glSw, showGrid);
    drawGrid();
    toast('Grid lines', showGrid ? 'ON' : 'OFF');
  });

  newBtn.addEventListener('click', () => {
    if(confirm('New canvas?')) newCanvas();
  });

  undoBtn.addEventListener('click', doUndo);
  redoBtn.addEventListener('click', doRedo);
  clearBtn.addEventListener('click', () => { if(confirm('Clear?')) clearAll(); });
  saveBtn.addEventListener('click', savePNG);

  exportBtn.addEventListener('click', exportJSON);
  importBtn.addEventListener('click', () => fileIn.click());
  fileIn.addEventListener('change', () => {
    const f = fileIn.files && fileIn.files[0];
    if(f) importJSONFile(f);
    fileIn.value = '';
  });

  // Hotkeys (minimal)
  window.addEventListener('keydown', (e) => {
    const mod = e.ctrlKey || e.metaKey;
    if(mod && e.key.toLowerCase() === 'z'){ e.preventDefault(); doUndo(); }
    if(mod && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))){ e.preventDefault(); doRedo(); }
    if(e.key.toLowerCase() === 'e'){ eraser = !eraser; setSwitch(erSw, eraser); }
    if(e.key.toLowerCase() === 'r'){ rainbow = !rainbow; setSwitch(rbSw, rainbow); }
  });

  // Init
  updateUI();
  setupCanvases();

  let resizeT = 0;
  window.addEventListener('resize', () => {
    clearTimeout(resizeT);
    resizeT = setTimeout(setupCanvases, 120);
  });

  toast('Ready', 'Draw with LMB');
})();
</script>
</body>
</html>
